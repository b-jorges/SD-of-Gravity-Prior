Perceived_VTan = abs(Actual_VTan)*SD_Factor_VY, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_VY),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],250)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
ggsave("Range of Remaining Error SDs.jpg", w=4, h=4)
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_VY),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],250)
error_Remaining = c(error_Remaining,f)
}
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],250)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
ggsave("Range of Remaining Error SDs.jpg", w=4, h=4)
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],250)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],500)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
ggsave("Range of Remaining Error SDs.jpg", w=4, h=4)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)") +
coord_cartesian(ylim = c(0,0.1))
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
Remaining_Response_Variability_SD = 0.05
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = cos(Perceived_Angle)*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response$Actual_VTan
response$Perceived_VTan
response$ActualAngle
RadiansToDegree(response$ActualAngle)
RadiansToDegree(response$Perceived_Angle)
RadiansToDegree(response$Perceived_VY)
response$Perceived_VY
cos(Perceived_Angle)
cos(DegreeToRadians(90))
cos(DegreeToRadians(91))
RadiansToDegree(response$Perceived_VY)
response$Perceived_VY
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.148
SD_Distance = 0.148
SD_Angle = 0.148
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],500)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)") +
coord_cartesian(ylim = c(0,0.1))
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],1000)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
error_Remaining
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.1,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],1000)
error_Remaining = c(error_Remaining,f)
}
GetSDMatchForG = function(SD_Gravity,n_Iterations,SD_RemainingVariability){
b = c()
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = unique(response2$Error_Per_TTC[response2$Condition == "Different g"])
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(SD_Gravity)
print(mean(b))
}
}
mean(b)
}
Tentative_SD_Gravity = seq(0.1,0.3,0.02) ####Again, takes a while
error_Gravity = c()
Tentative_SD_Gravity = seq(0.1,0.3,0.02) ####Again, takes a while
error_Gravity = c()
for (i in 1:length(Tentative_SD_Gravity)){
f = GetSDMatchForG(Tentative_SD_Gravity[i],250,SD_RemainingVariability=0.04)
error_Gravity = c(error_Gravity,f)
}
