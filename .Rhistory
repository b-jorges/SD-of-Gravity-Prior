SDError = sd(TemporalError),
#get the absolute temporal error with respect to the median of each condition as proxy for precision
PrecisionProxy = abs(TemporalError - median(TemporalError)))
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.104
SD_Distance = 0.148
SD_Angle = 0.104
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.07,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],1000)
error_Remaining = c(error_Remaining,f)
}
###Model mean responses, assuming that people assume 1g (not as a distribution,
###but as a fixed value) for all falling thingies
response <- response %>%
##Distance = (g/2)*t^2+vy*t+d0
#this is based on the physical formula for distance travelled from initial velocity, acceleration and time elapsed.
#We ignore motion in x direction, we only care about the falling part
#Distance would be the whole trajectory from peak, d0 is the part of the trajectory that's already been travelled,
#so the relevant value is the trajectory that still has to be travelled (aka Height of Disappearance)
##0 = (g/2)*t^2+vy*t+d0-Distance (d0 - Distance = Height of Disappearance)     ##solve for time
mutate(TemporalError = TemporalError-0.049259,
####get the time the object fell during the occlusion
PercentageOcclusion = OccludedTimeOfTrajectory/FlightDuration,
TimeFallingBeforeOcclusion = (0.5-PercentageOcclusion)*FlightDuration,
####get the last velocity they observed before occlusion:
LastObserved_vy = g*TimeFallingBeforeOcclusion,
####get the last velocity they observed before occlusion, including a correction for Aubert-Fleischl effect
####(we perceived pursued object at 80% of its speed during smooth pursuit)
LastObserved_vy_AFcorrected = g*TimeFallingBeforeOcclusion*0.8,
####Get the height at which the object disappears
MaxHeight = getYAtPeak(vy,g),
HeightAtDisappearance = MaxHeight-TimeFallingBeforeOcclusion^2*(g/2),
#get simulated values of the extrapolated motion
EstimatedTimeUnder1gAssumption = (-LastObserved_vy + (LastObserved_vy^2+4*(9.81/2)*
(HeightAtDisappearance))^0.5)/(9.81),
EstimatedTimeUnder1gAssumption_AFcorrected = (-LastObserved_vy_AFcorrected + (LastObserved_vy_AFcorrected^2+
4*(9.81/2)*
(HeightAtDisappearance))^0.5)/(9.81),
#get the simulated temporal error based on actual occluded time and the simulated extrapolated duration
TemporalErrorUnder1gAssumption = EstimatedTimeUnder1gAssumption-OccludedTimeOfTrajectory,
TemporalErrorUnder1gAssumption_AFcorrected = EstimatedTimeUnder1gAssumption_AFcorrected-OccludedTimeOfTrajectory,
#control whether everything went as it was supposed to:
ControlTime = (TimeFallingBeforeOcclusion+OccludedTimeOfTrajectory)-FlightDuration/2,
ControlTime2 = EstimatedTimeUnder1gAssumption - OccludedTimeOfTrajectory)
GetSDMatchForRemainingNoise = function(Remaining_Response_Variability_SD,n_Iterations){
b = c()
SD_Acceleration = 0.296
SD_Velocity = 0.104
SD_Distance = 0.148
SD_Angle = 0.104
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Acceleration)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = response2$Error_Per_TTC[response2$g == -9.81]
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(Remaining_Response_Variability_SD)
print(mean(b))}
}
mean(b)
}
#####get general idea of range of values
Tentative_SD_Remaining = seq(0,0.07,0.01) ###this takes a while!
error_Remaining = c()
for (i in 1:length(Tentative_SD_Remaining)){
f = GetSDMatchForRemainingNoise(Tentative_SD_Remaining[i],1000)
error_Remaining = c(error_Remaining,f)
}
RangeOfValesSDRemainingError = data.frame(SD=Tentative_SD_Remaining,Error=error_Remaining)
ggplot(RangeOfValesSDRemainingError, aes(SD,Error)) +
geom_point(size = 5) +
xlab("SD (s)") +
ylab("Error (s)")
ggsave("Range of Remaining Error SDs.jpg", w=4, h=4)
#Optimize over this function to get best SD fit for the remaining error
Optimization = optimize(GetSDMatchForRemainingNoise, c(0.03), n_Iterations = 1000, maximum = FALSE, lower = 0.02, upper = 0.06, tol = 0.001)
SD_RemainingVariability = Optimization$minimum
GetSDMatchForG = function(SD_Gravity,n_Iterations,SD_RemainingVariability){
b = c()
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
for (i in 1:n_Iterations){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory)
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response2 = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2) %>%
slice(1)
a = unique(response2$Error_Per_TTC[response2$Condition == "Different g"])
b = c(b,mean(a))
if (i==n_Iterations){
print("Round done")
print(SD_Gravity)
print(mean(b))
}
}
mean(b)
}
Tentative_SD_Gravity = seq(0.1,0.3,0.02) ####Again, takes a while
error_Gravity = c()
for (i in 1:length(Tentative_SD_Gravity)){
f = GetSDMatchForG(Tentative_SD_Gravity[i],250,SD_RemainingVariability=0.04)
error_Gravity = c(error_Gravity,f)
}
RangeOfValesSDGravity = data.frame(SD=Tentative_SD_Gravity,Error=error_Gravity)
ggplot(RangeOfValesSDGravity, aes(SD,Error)) +
geom_point(size=5) +
xlab("SD (m/s²)") +
ylab("Error (s)")
Tentative_SD_Gravity = seq(0,0.24,0.03) ####Again, takes a while
error_Gravity = c()
for (i in 1:length(Tentative_SD_Gravity)){
f = GetSDMatchForG(Tentative_SD_Gravity[i],250,SD_RemainingVariability=0.04)
error_Gravity = c(error_Gravity,f)
}
RangeOfValesSDGravity = data.frame(SD=Tentative_SD_Gravity,Error=error_Gravity)
ggplot(RangeOfValesSDGravity, aes(SD,Error)) +
geom_point(size=5) +
xlab("SD (m/s²)") +
ylab("Error (s)")
ggsave("Range of Gravity SDs.jpg", w=4, h=4)
#Optimize over this function to get best SD fit for g
Optimization2 = optimize(GetSDMatchForG, c(0.15), n_Iterations = 1000, SD_RemainingVariability = SD_RemainingVariability,
maximum = FALSE, lower = 0.2, upper = 0.3, tol = 0.01)
Optimized_SD_Gravity = Optimization2$minimum
#Optimize over this function to get best SD fit for g
Optimization2 = optimize(GetSDMatchForG, c(0.15), n_Iterations = 1000, SD_RemainingVariability = SD_RemainingVariability,
maximum = FALSE, lower = 0.1, upper = 0.2, tol = 0.01)
Optimized_SD_Gravity = Optimization2$minimum
#get the correspondance in terms of "Weber fractions"
pnorm(9.09,9.81,1.156)
#get the correspondance in terms of "Weber fractions"
pnorm(9.09,9.81,0.156)
#get the correspondance in terms of "Weber fractions"
pnorm(1,9.81,0.156)
Optimized_SD_Gravity
#get the correspondance in terms of "Weber fractions"
pnorm(9.09,9.81,Optimized_SD_Gravity*9.81)
9.81/9.09
#get the correspondance in terms of "Weber fractions"
pnorm(8.7,9.81,Optimized_SD_Gravity*9.81)
#get the correspondance in terms of "Weber fractions"
pnorm(8.8,9.81,Optimized_SD_Gravity*9.81)
#get the correspondance in terms of "Weber fractions"
pnorm(8.78,9.81,Optimized_SD_Gravity*9.81)
#get the correspondance in terms of "Weber fractions"
pnorm(8.781,9.81,Optimized_SD_Gravity*9.81)
#get the correspondance in terms of "Weber fractions"
pnorm(8.78,9.81,Optimized_SD_Gravity*9.81)
8.78/9.09
9.81/8.78
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
SD_Gravity = Optimized_SD_Gravity
SD_RemainingVariability = SD_RemainingVariability
for (i in 1:100){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VY = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor,
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
Remaining_Response_Variability = rnorm(length(g),0,SD_RemainingVariability),
SD_Factor_Timing = abs(rnorm(length(g),1,SD_TimeDecay)),
Perceived_G = 9.81*SD_Factor_G,
Perceived_VY = LastObserved_vy*SD_Factor_VY,
Perceived_Distance = HeightAtDisappearance*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty*SD_Factor_Timing + Remaining_Response_Variability,
TemporalError_Sim = (TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory))
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2)
response3 = response %>%
select(id,block,trial,g,vy_factor,Occlusion_factor,Condition,SD_per_TTC_Modelled,SD_per_TTC_Real,Perceived_Distance,SD_Real_Aux)
response2 = rbind(response2,response3)
print(i)
}
for (i in 1:100){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = (TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory))
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2)
response3 = response %>%
select(id,block,trial,g,vy_factor,Occlusion_factor,Condition,SD_per_TTC_Modelled,SD_per_TTC_Real,Perceived_Distance,SD_Real_Aux)
response2 = rbind(response2,response3)
print(i)
}
response3 = c()
response2 = c()
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
SD_Gravity = Optimized_SD_Gravity
SD_RemainingVariability = SD_RemainingVariability
for (i in 1:100){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = (TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory))
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2)
response3 = response %>%
select(id,block,trial,g,vy_factor,Occlusion_factor,Condition,SD_per_TTC_Modelled,SD_per_TTC_Real,Perceived_Distance,SD_Real_Aux)
response2 = rbind(response2,response3)
print(i)
}
###########################
#######Make plot of SD fit between Observed and Simulated //
###########################
response3 = c()
response2 = c()
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
SD_Gravity = Optimized_SD_Gravity
SD_RemainingVariability = SD_RemainingVariability
for (i in 1:100){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = (TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory))
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2)
response3 = response %>%
select(id,block,trial,g,Occlusion_factor,Condition,SD_per_TTC_Modelled,SD_per_TTC_Real,Perceived_Distance,SD_Real_Aux)
response2 = rbind(response2,response3)
print(i)
}
response3 = c()
response2 = c()
SD_Velocity = 0.1
SD_Distance = 0.148
SD_Angle = 0.1
AF_Factor = 0.8
SD_Gravity = Optimized_SD_Gravity
SD_RemainingVariability = SD_RemainingVariability
for (i in 1:100){
response = response %>%
mutate(SD_Factor_G = abs(rnorm(length(g),1,SD_Gravity)),
SD_Factor_VTan = abs(rnorm(length(g),1,SD_Velocity))*AF_Factor, #account for Aubert-Fleischl
SD_Factor_Distance = abs(rnorm(length(g),1,SD_Distance)),
SD_Factor_Angle = abs(rnorm(length(g),1,SD_Angle)),
Remaining_Response_Variability = rnorm(length(g),0,Remaining_Response_Variability_SD),
Perceived_G = 9.81*SD_Factor_G,
Actual_VTan = (LastObserved_vy^2+vx^2)^0.5, #pythagoras
Perceived_VTan = abs(Actual_VTan)*SD_Factor_VTan, #tangens ratio
ActualAngle = atan(vx/LastObserved_vy), #get actual angle
Perceived_Angle = (abs(ActualAngle)*SD_Factor_Angle),
Perceived_VY = abs(cos(Perceived_Angle))*Perceived_VTan, #vertical velocity is not sensed directly, it needs to be recovered from noisy info about tangential velocity and angle-to-vertical!
Perceived_Distance = abs(HeightAtDisappearance)*SD_Factor_Distance)
response = response %>%
mutate(TemporalEstimateWithUncertainty = (-Perceived_VY +
(Perceived_VY^2 +
2*Perceived_G*Perceived_Distance)^0.5)/
Perceived_G,
TemporalEstimateWithUncertainty_AndResponseSD = TemporalEstimateWithUncertainty + Remaining_Response_Variability,
TemporalError_Sim = (TemporalEstimateWithUncertainty_AndResponseSD-OccludedTimeOfTrajectory))
#Here I get the SD of the participants timing - modelled responses and get actual responses
response = response %>%
group_by(id,g,vy,LongOcclusion,Condition) %>%
mutate(SD_Sim_Aux = sd(TemporalError_Sim,na.rm = TRUE),
SD_Real_Aux = sd(TemporalError,na.rm = TRUE))
response = response %>%
group_by(g,vy,LongOcclusion,Condition) %>%
mutate(SD_per_TTC_Modelled = mean(SD_Sim_Aux),
SD_per_TTC_Real = mean(SD_Real_Aux),
Error_Per_TTC = (SD_per_TTC_Real-SD_per_TTC_Modelled)^2)
response3 = response %>%
select(id,block,trial,vy,LongOcclusion, g,Condition,SD_per_TTC_Modelled,SD_per_TTC_Real,Perceived_Distance,SD_Real_Aux)
response2 = rbind(response2,response3)
print(i)
}
response2 = response2 %>%
group_by(id,block,trial,g,vy,LongOcclusion,Condition) %>%
mutate(Modelled_SD = mean(SD_per_TTC_Modelled),
Real_SD = mean(SD_per_TTC_Real)) %>%
slice(1) %>%
mutate(vy_factor = case_when(
vy == 6 ~ "6 m/s",
vy == 4.5 ~ "4.5 m/s",
),
Occlusion_factor = case_when(
LongOcclusion == 1 ~ "Long Occlusion",
LongOcclusion == 0 ~ "Short Occlusion",
)
)
response3 = rbind(response2,response2)
response3$SD = c(response2$Modelled_SD,response2$Real_SD)
response3$TypeOfSD = c(rep("Simulated",length(response2$g)),rep("Observed",length(response2$g)))
#######Plot the SDs
ggplot(response3[response3$Condition == "Different g",],aes(x = g, y = SD, color = TypeOfSD)) +
geom_point(size = 5) +
ylab("SD (s)") +
xlab("Gravity") +
theme(legend.position = "top") +
scale_color_manual(name = "",
values = c(BlauUB,LightRed)) +
facet_grid(vy_factor~Occlusion_factor) +
scale_x_discrete(name = "Gravity (g)",
labels=c("0.7g", "0.85g", "1g", "1.15g", "1.3g"))
ggsave("SimulatedSDs_1Fit.jpg", w=6, h=6)
#######Get plots of SD per ID, VY, G, Occlusion Category
ggplot(response3[response3$Condition == "Different g" & response3$TypeOfSD == "Observed",],aes(x = g, y = SD_Real_Aux, color = id)) +
geom_line(size = 2) +
ylab("SD (s)") +
xlab("Gravity") +
theme(legend.position = "top") +
scale_color_manual(name = "",
values = colorRampPalette(c("grey",Yellow))(9)) +
facet_grid(vy_factor~Occlusion_factor) +
scale_x_discrete(name = "Gravity (g)",
labels=c("0.7g", "0.85g", "1g", "1.15g", "1.3g"))
ggsave("RealSDsPerSubject.jpg", w=6, h=6)
Optimized_SD_Gravity
9.81/8.78
Optimized_SD_Gravity*9.81
9.81/8.78
#an SD of about 0.148 for the distance, more or less
pnorm(1.07,1,0.104)
