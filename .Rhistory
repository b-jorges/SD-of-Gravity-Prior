group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/4)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Motion + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
ggplot(Psychometric,aes(Difference,Answer,color=as.factor(Motion))) +
binomial_smooth() +
facet_grid(velH~ID) +
xlab("Ratio Target/Comparison") +
ylab("Probability Target Bigger") +
coord_cartesian(xlim = c(-5,1))
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/4)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric
Psychometric = Psychometric %>%
filter(abs(Difference) < 5)
ggplot(Psychometric,aes(Difference,Answer,color=as.factor(Motion))) +
binomial_smooth() +
facet_grid(velH~ID) +
xlab("Ratio Target/Comparison") +
ylab("Probability Target Bigger") +
coord_cartesian(xlim = c(-5,1))
install.packages("lemon")
ggplot(Psychometric,aes(Difference,Answer,color=Congruent)) +
binomial_smooth() +
facet_grid(velH~ID) +
xlab("Ratio Target/Comparison") +
ylab("Probability Target Bigger") +
coord_cartesian(xlim = c(-5,1))
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/4)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*velH_Subject < 0 ~ "incongruent",
velH*velH_Subject > 0 ~ "congruent",
velH*velH_Subject == 0 ~ "1no motion"
)
)
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/4)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
Psychometric = Psychometric %>%
filter(abs(Difference) < 5)
ggplot(Psychometric,aes(Difference,Answer,color=Congruent)) +
binomial_smooth() +
facet_grid(velH~ID) +
xlab("Ratio Target/Comparison") +
ylab("Probability Target Bigger") +
coord_cartesian(xlim = c(-5,1))
SimulatePsychometricFunction = function(ID,Motion,velH, reps){
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/8)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
}
Analyze_Pychometric_Precision = function(Psychometric){
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference,velH)) %>%
distinct() %>%
filter(abs(Difference) < 5)
Psychometric = Psychometric %>% ###for this test, we can collapse right and leftward motion because we expect the same effect in terms of thresholds for both
mutate(
MotionCondition = case_when(
Motion == 0 ~ "No",
Motion != 0 ~ "Yes"
)
)
###precision = slope for Difference (the steeper the slope, the more sensitive) ...
###so if there is an interaction between Motion Condition and Difference, that means that it changes the slope
mod1 = glmer(cbind(Yes, Total - Yes) ~ as.factor(MotionCondition)*Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ as.factor(MotionCondition) + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2?
}
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH,Congruent)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Congruent + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
Power_Accuracy = c()
nIterations = 100
out2 <- replicate(nIterations, {
Analyze_Pychometric_Accuracy(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps))})
hist(out2) ###Distribution of p values
Power_Accuracy = mean(out2 < 0.05) ###Power is the times the difference between the two models is significant
Power_Accuracy ###This is the power for the PSEs
Power_Precision
Power_Accuracy
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH,Congruent)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Congruent + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion/8)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*0.033*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH,Congruent)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Congruent + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
Analyze_Pychometric_Accuracy = function(Psychometric){
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH,Congruent)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Congruent + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
}
Analyze_Pychometric_Accuracy = function(Psychometric){
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference, velH,Congruent)) %>%
distinct() %>%
filter(abs(Difference) < 5)
mod1 = glmer(cbind(Yes, Total - Yes) ~ Congruent + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ Difference + (1 | ID) + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2
print(anova(mod1,mod2)$`Pr(>Chisq)`[2])
}
Power_Accuracy = c()
nIterations = 100
out2 <- replicate(nIterations, {
Analyze_Pychometric_Accuracy(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps))})
hist(out2) ###Distribution of p values
Power_Accuracy = mean(out2 < 0.05) ###Power is the times the difference between the two models is significant
Power_Accuracy ###This is the power for the PSEs
######power for very low estimates of effect size: difference of 0.1 m/s in PSEs, and JNDs 1/5 higher when self-motion is simulated
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
Power_Accuracy = c()
nIterations = 100
out2 <- replicate(nIterations, {
Analyze_Pychometric_Accuracy(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out2) ###Distribution of p values
Power_Accuracy = mean(out2 < 0.05) ###Power is the times the difference between the two models is significant
Power_Accuracy ###This is the power for the PSEs
SimulatePsychometricFunction = function(ID,Motion,velH, reps){
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps, PSE_Diff, JND_Diff)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion*PSE_Diff)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*JND_Diff*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
}
######power for very low estimates of effect size: difference of 0.1 m/s in PSEs, and JNDs 1/5 higher when self-motion is simulated
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
Power_Accuracy = c()
nIterations = 100
out2 <- replicate(nIterations, {
Analyze_Pychometric_Accuracy(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out2) ###Distribution of p values
Power_Accuracy = mean(out2 < 0.05) ###Power is the times the difference between the two models is significant
Power_Accuracy ###This is the power for the PSEs
SimulatePsychometricFunction = function(ID,Motion,velH, reps,PSE_Diff, JND_Diff){
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion*PSE_Diff)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.02), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*JND_Diff*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
}
######power for very low estimates of effect size: difference of 0.1 m/s in PSEs, and JNDs 1/5 higher when self-motion is simulated
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
Power_Accuracy = c()
nIterations = 100
out2 <- replicate(nIterations, {
Analyze_Pychometric_Accuracy(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out2) ###Distribution of p values
Power_Accuracy = mean(out2 < 0.05) ###Power is the times the difference between the two models is significant
Power_Accuracy ###This is the power for the PSEs
Power_Accuracy
Power_Precision
SimulatePsychometricFunction = function(ID,Motion,velH, reps,PSE_Diff, JND_Diff){
Psychometric = expand.grid(ID=ID, Motion=Motion, velH=velH, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,0.15),
SD_Factor_ID = rnorm(1,1,0.15))
Psychometric = Psychometric %>%
group_by(ID,Motion,velH) %>%
mutate(
EffectOfSelfMotion.Accuracy = (2*velH/3+Motion*PSE_Diff)*abs(PSE_Factor_ID), ###get PSE: +/- 1/8 of selfmotion, aaaand some inter-subject variability (PSE_Factor_ID)
velH_pest_factor = rcauchy(length(reps),1,0.1), ###get vector of presented stimulus velocities in accordance with staircase (lots of values around PSE, fewer in the periphery)
velH_shown=EffectOfSelfMotion.Accuracy*velH_pest_factor, ###translates from values around 1 to values around PSE
####Get SD for cumulative Gaussian: 0.15*PSE + 0.05*PSE if selfmotion is present, aaaand some inter-subject variability (SD_Factor_ID)
EffectOfSelfMotion.Precision = (abs(EffectOfSelfMotion.Accuracy*0.1)+abs(EffectOfSelfMotion.Accuracy*JND_Diff*(Motion!=0)))*SD_Factor_ID,
####cram everything into a cumulative Gaussian (pnorm()):
AnswerProbability = pnorm(abs(velH_shown),abs(EffectOfSelfMotion.Accuracy),EffectOfSelfMotion.Precision),
####Get difference between target velocity and PEST velocity
Difference = abs(velH_shown) - abs(velH),
##get binary answer from probability for each trial
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
###prepare for glmer() - needs sum of YES/Total per stimulus strength and condition
Psychometric = Psychometric %>%
group_by(ID,Motion,velH,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(Motion))
Psychometric =  Psychometric %>%
mutate(Congruent = case_when(
velH*Motion < 0 ~ "incongruent",
velH*Motion > 0 ~ "congruent",
velH*Motion == 0 ~ "1no motion"
)
)
}
Analyze_Pychometric_Precision = function(Psychometric){
Psychometric =
select(Psychometric,c(ID,Motion,Yes,Total,Difference,velH)) %>%
distinct() %>%
filter(abs(Difference) < 5)
Psychometric = Psychometric %>% ###for this test, we can collapse right and leftward motion because we expect the same effect in terms of thresholds for both
mutate(
MotionCondition = case_when(
Motion == 0 ~ "No",
Motion != 0 ~ "Yes"
)
)
###precision = slope for Difference (the steeper the slope, the more sensitive) ...
###so if there is an interaction between Motion Condition and Difference, that means that it changes the slope
mod1 = glmer(cbind(Yes, Total - Yes) ~ as.factor(MotionCondition)*Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
mod2 = glmer(cbind(Yes, Total - Yes) ~ as.factor(MotionCondition) + Difference + (1 | ID)  + (1 | velH),
family = binomial(link = "probit"),
data = Psychometric)
anova(mod1,mod2)$`Pr(>Chisq)`[2] ##Model 1 beats model 2?
}
######power for reasonable estimates of effect size: difference of 0.25 m/s in PSEs, and JNDs 1/3 higher when self-motion is simulated
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 1/8, JND_Diff = 0.033))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
######power for very low estimates of effect size: difference of 0.1 m/s in PSEs, and JNDs 1/5 higher when self-motion is simulated
Power_Precision = c()
nIterations = 100
out <- replicate(nIterations, {
Analyze_Pychometric_Precision(SimulatePsychometricFunction(ID=ID, Motion=Motion, velH=velH, reps=reps, PSE_Diff = 0.05, JND_Diff = 0.02))})
hist(out) ###Distribution of p values
Power_Precision = mean(out < 0.05) ###Power is the times the difference between the two models is significant
Power_Precision ###This is the power for the JNDs
