{
    "contents" : "source(\"MERpsychophysics.r\")\n\n#this ensure that your output will match mine\nset.seed(32787)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                 \n\n#psychometric function to fit single-subject data\ndatafr.S1 <- MERsimulate(fixeff = c(-7.2, 0.0875), nsubject = 1, constant = T)     \nplot(Longer/Total ~ X, data = datafr.S1)\nfit.S1 = psych.function(ps.formula = cbind(Longer, Total - Longer) ~ X, ps.link = \"probit\",\n                        ps.data = datafr.S1, x.range = c(40, 120), ps.lines = T, ps.col = \"black\")\nfit.S1\n\n#this simulates a second condition or a second participant\ndatafr.S2 <- MERsimulate(fixeff = c(-6.8, 0.0875), nsubject = 1, constant = T)     \npoints(Longer/Total ~ X, data = datafr.S2, col = \"red\")\nfit.S2 = psych.function(ps.formula = cbind(Longer, Total - Longer) ~ X, ps.link = \"probit\",\n                        ps.data = datafr.S2, x.range = c(40, 120), ps.lines = T, ps.col = \"red\")\nfit.S2\n\n#Analysis of the clustered data: Mixed Models\n#In two steps: Simulate a dataset with a categorical variable (\"condition\")\ndatafr.1 <- MERsimulate(fixeff = c(-7.5, 0.0875), nsubject = 6, constant = T)                               \nlevels(datafr.1$Subject) = c(\"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\")\ndatafr.1$condition = rep(\"A\", 54)\n\ndatafr.2 <- MERsimulate(fixeff = c(-7, 0.0875),nsubject = 6, constant = T)                              \nlevels(datafr.2$Subject) = c(\"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\")\ndatafr.2$condition = rep(\"B\", 54)\n\ndatafr = merge(datafr.1, datafr.2, all = T)\ndatafr$condition = as.factor(datafr$condition)\n\n#How to estimate the PSE in the two condtions?\n#1)use MERtreatment (note, you have to provide also the dataframe to the function)\nformula.mod = cbind(Longer, Total - Longer) ~ X * condition + (1 + X| Subject)\nmod1 <- glmer(formula = formula.mod, family = binomial(link = \"probit\"), data = datafr)\nxplode.mod1 = xplode.mer(model = mod1, name.cont = \"X\", name.fact = \"condition\")\nMERtreatment(xplode.mod1, datafr)\n\n#write your function to estimate jnd and pse with a bootstrap method:\nfun2mod1 = function(mer.obj){\n  #allocate space: 4 parameters (jnd_A, jnd_B, pse_A, pse_B)\n  jndpse = vector(mode = \"numeric\", length = 4)\n  names(jndpse) = c(\"jnd_A\",\"jnd_B\", \"pse_A\", \"pse_B\")\n  \n  jndpse[1] = qnorm(0.75)/fixef(mer.obj)[2] #jnd_A\n  jndpse[2] = qnorm(0.75)/(fixef(mer.obj)[2] + fixef(mer.obj)[4]) #jnd_B\n  jndpse[3] = -fixef(mer.obj)[1]/fixef(mer.obj)[2] #pse_A\n  jndpse[4] = -(fixef(mer.obj)[1] + fixef(mer.obj)[3])/(fixef(mer.obj)[2] + fixef(mer.obj)[4]) #pse_B\n  return(jndpse)\n}\n\n#Now use the pseMer function\nBootEstim = pseMer(mod1, B = 200, FUN = fun2mod1)\n\n#...and the estimates:\nBootEstim[[1]]\n\n#quick plotting\nlibrary(ggplot2)\ndatafr$predict.mod1 = predict(mod1, type = \"response\")\nggplot(datafr, aes(x = X, y = Longer/Total, color = condition)) +\n  ylab(\"Probability\") + xlab(\"X\") +\n  geom_point() +\n  geom_line(aes(x = X, y = predict.mod1)) +\n  facet_wrap(~ Subject, ncol = 3)\n\n#2)alternatively, run twice the model with a different baseline\n#This way we can choose the baseline \ndatafr$conditionA = ifelse(datafr$condition == \"A\", 0 , 1)\n\n#fit the GLMM(probit link function)\nformula.modA = cbind(Longer, Total - Longer) ~ X * conditionA + (1 + X| Subject)\nmodA <- glmer(formula = formula.modA, family = binomial(link = \"probit\"), data = datafr, nAGQ = 1)\nsummary(modA)\n\n#New: xplode.mer (indicate the names of the predictor)\nxplode.modA = xplode.mer(model = modA, name.cont = \"X\", name.fact = \"conditionA\")\n\n#run MERdelta.probit on the xplode object\n#This is the PSE and JND for A (B is coded as a dummy == 1)\nMERdelta.probit(xplode.modA)\n\n#pse and jnd CI with the bootstrap (this takes time). The function based is a very simple one, based on bootMer{lme4.1}\nestimA = pseMer(modA)\n\n#Now condition B is the baseline\ndatafr$conditionB = ifelse(datafr$condition == \"B\", 0 , 1)\n\n#fit the GLMM(probit link function)\nformula.modB = cbind(Longer, Total - Longer) ~ X * conditionB+ (1 + X| Subject)\nmodB <- glmer(formula = formula.modB, family = binomial(link = \"probit\"), data = datafr, nAGQ = 1)\n\nxplode.modB = xplode.mer(model = modB, name.cont = \"X\", name.fact = \"conditionB\")\n#This is the PSE and JND for B (A is coded as a dummy == 1)\nMERdelta.probit(xplode.modB)\n\n#pse and jnd CI with the bootstrap (this takes time). The function based is a very simple one, based on bootMer{lme4.1}\nestimB = pseMer(modB)\n\n#3) I would like to implement a third method based on the variance-covariance matrix.\n#For the moment is not ready, as I don't know how to find the three-terms covariance. Without that, the CI is unprecise.\n#Define the psychometric function and run the model just once\ndefine.mod = list(pf1 = list(intercept = 1, slope = 2),\n                    pf2 = list(intercept = c(1,3), slope = c(2,4)))\n\nxplode.mod = xplode.mer(model = modA, name.cont = \"X\", name.fact = \"condition\", define.pf = define.mod)\nMERdelta.probit(xplode.mod)\n\n",
    "created" : 1438249355733.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3125169637",
    "id" : "333B9F61",
    "lastKnownWriteTime" : 1438689700,
    "path" : "~/Documents/Projects/MER/MERpsychophysics.1/MERdemo.r",
    "project_path" : "MERdemo.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}