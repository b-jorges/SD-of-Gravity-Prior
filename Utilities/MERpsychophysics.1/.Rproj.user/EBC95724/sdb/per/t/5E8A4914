{
    "contents" : "#xplode.mer extract values and parametrs from a mer object. The FUN defines the statistics of interests\n\nxplode.mer = function(model, name.cont = NA, name.factor = NA, names.response = NA,\n                      define.pf = list(pf1 = list(intercept = 1, slope = 2)))\n  {\n\txplode = vector(\"list\", 22)\n\tnames(xplode) = c( \"fixef\", \"fixef.vcov\", \"n.psych.fun\",\"factor.col\", \"factor.parnames\",\n                      \"psychometrics\", \"ranef.stddev\", \"ranef.VarCov\", \"multirand\", \n\t                    \"Groups\",\"Gp\",\"Groups.levels\", \"Groups.colnames\", \"flist\", \"nobs\",\n                      \"size\", \"response.colnames\", \"model.frame\", \"model.matrix\", \"rps\",\n                      \"formula\", \"family\")\n  \n  \n  #1)fixed effects--------------------------\n\txplode$fixef = fixef(model)\n\t\n  #Variance-Covariance Matrix of the fixed effects\n\txplode$fixef.vcov = vcov(model)\n\t\n  #Number of psychometric functions\n\txplode$n.psych.fun = length(define.pf)\n  \n  #(the names of the parameters in the design matrix)\n  #to do: change from factor to treatment\n\tif(!is.na(name.factor)){\n\t  xplode$factor.col = which(names(model.frame(model)) == name.factor)\n\t  n.factors = length(levels(model.frame(model)[,xplode$factor.col]))\n\t  factor.parnames = vector(\"character\", n.factors)\n\t  for(i in 1:n.factors){\n\t    xplode$factor.parnames[i] = paste(name.factor, levels(model.frame(model)[,xplode$factor.col])[i], sep = \"\")\n\t  }\n\t}\n  \n\t#re-arrange the fixed effects into n psychometric functions\n\t#rename the n psychometric functions\n\txplode$psychometrics = vector(mode = \"list\", length = xplode$n.psych.fun)\n\tnames.pf = character(length = xplode$n.psych.fun)\n\t\n  for(i in 1:xplode$n.psych.fun){\n\t\tnames.pf[i] =  paste(\"pf\", i, sep = \"\")\n\n    intercept.pointers = define.pf[[i]]$intercept\n \t\tslope.pointers = define.pf[[i]]$slope\n    \n\t\t#estimate and Variance of the Intercept\n\t\txplode$psychometrics[[i]]$intercept = numeric(length = 2)\n    names(xplode$psychometrics[[i]]$intercept) = c(\"Estimate\", \"Variance\")\n    xplode$psychometrics[[i]]$intercept[1] = sum(fixef(model)[intercept.pointers])\n    \n    if(length(intercept.pointers) == 1)\n      {\n      xplode$psychometrics[[i]]$intercept[2] = xplode$fixef.vcov[intercept.pointers, intercept.pointers]\n    }else\n      {\n      kombo.intercept = kombo(intercept.pointers)\n      xplode$psychometrics[[i]]$intercept[2] =\n        xplode$fixef.vcov[kombo.intercept[[1]][1,1], kombo.intercept[[1]][2,1]] +\n        xplode$fixef.vcov[kombo.intercept[[1]][1,2], kombo.intercept[[1]][2,2]] +\n        (2 * xplode$fixef.vcov[kombo.intercept[[2]][1,1], kombo.intercept[[2]][2,1]])\n    }\n\t\t\n\t\t#estimate and Variance of the Slope\n\t\txplode$psychometrics[[i]]$slope = numeric(length = 2)\n\t\tnames(xplode$psychometrics[[i]]$slope) = c(\"Estimate\", \"Variance\")\n\t\txplode$psychometrics[[i]]$slope[1] = sum(fixef(model)[slope.pointers])\n\t\tif(length(slope.pointers) == 1){\n\t\t  xplode$psychometrics[[i]]$slope[2] = xplode$fixef.vcov[slope.pointers, slope.pointers]\n\t\t}else{\n\t\t  kombo.slope = kombo(slope.pointers)\n\t\t  xplode$psychometrics[[i]]$slope[2] =\n\t\t    xplode$fixef.vcov[kombo.slope[[1]][1,1], kombo.slope[[1]][2,1]] +\n\t\t    xplode$fixef.vcov[kombo.slope[[1]][1,2], kombo.slope[[1]][2,2]] +\n\t\t    (2 * xplode$fixef.vcov[kombo.slope[[2]][1,1], kombo.slope[[2]][2,1]])\n\t\t}\n\t}\n\tnames(xplode$psychometrics) = names.pf\n  xplode$psychometrics$pf1$cov = xplode$fixef.vcov[name.cont,\"(Intercept)\"]\n\t\n  #2)random effects (univariate or multivariate)-------------\n\t#Str. Dev.\n\txplode$ranef.stddev <- as.numeric(attr(VarCorr(model)[[1]], \"stddev\"))\n\t\n\t#Variance-Covariance Matrix of the random effects (two random effect and correlation)\n\tif(length(xplode$ranef.stddev) > 1){   \n\t\txplode$ranef.VarCov = nearPD(VarCorr(model)[[1]])$mat\n\t\txplode$multirand = TRUE\t\n\t\t}\n\t\t\t\t\n\t#3)family\n\txplode$family = family(model)\n\n\t#number of subjects and names\n\txplode$Gp = getME(model, name = \"Gp\")\n\txplode$Groups.levels = levels(getME(model, name = \"flist\")[[1]])\n\txplode$flist = getME(model, name = \"flist\")\n  \n\t#find the column number in the frame specifiyng for the grouping factor\n\txplode$Groups.colnames = names(xplode$flist)\n\t\n  xplode$Groups = length(xplode$Groups.levels)\n\n  xplode$nobs = nobs(model)\n\txplode$size = rowSums(model.response(model.frame(model))) #----------------------------> check this with binaries \n\n  #03.01.14: Check this\n  if(is.na(names.response)){\n    xplode$response.colnames = colnames(model.response(model.frame(model))) \n\t}else{\n\t  xplode$response.colnames = names.response\n\t}\n\n  xplode$model.frame = model.frame(model)\n  xplode$model.matrix = model.matrix(model)\n  \n\t#Rows per each Subject\n\txplode$rps = table(getME(model, \"flist\")[[1]])\n  \n  #formula\n  xplode$formula = formula(model)\n    \n  #modified on 14.11.2013 (yet not tested)\t\n\tclass(xplode) = \"xplode\"\n\t\n\t#create the methds for the class, i.e., print, summary, ect.\n\t#print.xplode <- function(x, ...){\n\t#\t\tcat(\"This is my vector:\\n\")\n\t#\t\tcat(paste(x[1:5]), \"...\\n\")\n\t#}\n\t\n\treturn(xplode)\n  }",
    "created" : 1398155070766.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3696934369",
    "id" : "5E8A4914",
    "lastKnownWriteTime" : 1398160927,
    "path" : "~/Documenti/Ale/MERpsychophysics.1/xplode.mer.r",
    "project_path" : "xplode.mer.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}